# -*- coding: utf-8 -*-
"""
Created on Wed Jul 10 12:26:03 2019

@author: rahmann
"""

import pickle
import numpy as np
import matplotlib.pyplot as plt
from PIL import Image
from scipy.signal import savgol_filter, find_peaks, peak_widths

#%% EPL conversion
def convert2EPL(test_path, offset, model_pckl, cm_pix, dark_path, flat_path, cropped_view=None, plot=False):
    """
    Function that takes in the designated raw test and converts to EPL. Optionally plots the result as well.
    =============
    --VARIABLES--
    test_path:          Path to an individual raw test image (.tif)
    offset:             Background EPL value correction. Given as either a tuple of slices that designate a region outside the spray,
                            or as a float if the offset value is known beforehand.
    model_pckl:         White beam model to be used. Generated by the specific whitebeam_*.py script (.pckl).
    cm_pix:             Pixel to cm conversion, dependent on experimental setup (scalar).
    dark_path:          Path to the image to be used for dark current subtraction (.tif).
    flat_path:          Path to the image to be used for flat field normalization (.tif).
    cropped_view:       Optional integer array parameter to crop down the image before conversion. Defaulted to None (int).
    plot:               Check to see if plots are wanted. Defaulted to False (boolean).
    """
    
    f = open(model_pckl, "rb")
    model = pickle.load(f)
    f.close()
    
    dark = np.array(Image.open(dark_path))
    flatfield = np.array(Image.open(flat_path))
    flatfield_darksub = flatfield - dark
    
    beam_middle = np.zeros((flatfield_darksub.shape[1]))
    for i in range(flatfield_darksub.shape[1]):
        beam_middle[i] = np.argmax(savgol_filter(flatfield_darksub[:,i], 55, 3))
        
    beam_middle_avg = int(np.mean(beam_middle).round())
    
    angles = model[0]
    angle_to_px = [beam_middle_avg+3500*np.tan(x*10**-3)/cm_pix for x in angles]
    
    data = np.array(Image.open(test_path))
    data_norm = (data-dark) / flatfield_darksub
    
    data_epl = np.empty(np.shape(data_norm), dtype=float)
    
    if type(cropped_view) == type(None):
        cropped_view = np.linspace(1, data_norm.shape[0])
        
    for z, _ in enumerate(cropped_view):
        j = np.argmin(abs(z-np.array(angle_to_px)))
        data_epl[z, :] = model[1][j](data_norm[z, :])
        
    if type(offset) == tuple:
        offset_epl = data_epl[offset[0], offset[1]]
        data_epl -= offset_epl
    else:
        data_epl -= offset
        
    if plot:
        plt.imshow(data_epl, vmin=0, vmax=1)
        plt.colorbar
        plt.title('EPL [cm] Mapping of Spray')
        
    return data_epl

#%% Ellipse fitting functions for comparing EPL value against "optical diameter"
def ellipse(data_epl, position, cm_pix, peak_width=20, relative_height=0.8, plot=False):
    """
    Function that takes in the EPL image and finds the best elliptical fit EPL diameter. 
    Optionally plots the result against the "optical diameter" as well for quick diagnostic of single image.
    =============
    --VARIABLES--
    data_epl:           EPL converted image of spray from convert2EPL function (array).
    position:           Vertical pixel location for the elliptical fitting plot (integer).
    peak_width:         Width in pixels to be used for the find_peaks function. Defaulted to 20 px (integer).
    relative_height:    Relative height to be used for the peak_widths function. Defaulted to 0.8 for the "fifth_maximum" (scalar).
    cm_pix:             Pixel to cm conversion, dependent on experimental setup (scalar).
    plot:               Check to see if plots are wanted. Defaulted to False (boolean).
    """
    
    peaks, _ = find_peaks(savgol_filter(data_epl[position, :], 105, 7), width=peak_width, prominence=0.1)
    [relative_width, relative_max, lpos, rpos] = peak_widths(savgol_filter(data_epl[position, :], 105, 7), peaks, rel_height=relative_height)
    relative_width = relative_width[0]
    relative_max = relative_max[0]
#    model_epl, fitted_graph, epl_graph = ideal_ellipse(y=savgol_filter(data_epl[position, :], 105, 7)[int(round(lpos[0])):int(round(rpos[0]))], relative_width=relative_width, relative_max=relative_max, dx=cm_pix)
    model_epl, fitted_graph, epl_graph = ideal_ellipse(y=data_epl[position, :][int(round(lpos[0])):int(round(rpos[0]))], relative_width=relative_width, relative_max=relative_max, dx=cm_pix)

    
    if plot:
        plot_ellipse(epl_graph, fitted_graph)
        
        plt.figure()
        plt.imshow(data_epl, vmin=0, vmax=1)
        plt.plot([position]*len(data_epl[position,:]), color='r', linestyle='--')
        plt.colorbar()
        plt.title('EPL [cm] Mapping of Spray')
        
        plt.figure()
        plt.plot(data_epl[position, :])
        plt.title('Line Scan at ' + str(position))
        plt.xlabel('Horizontal Location [px]')
        plt.ylabel('EPL [cm]')
    
def ideal_ellipse(y, relative_width, relative_max, dx, units='cm'):
    """
    Function that takes in a line scan and returns the best fit ellipse.
    =============
    --VARIABLES--
    y:                  Intensity line scan values (array).
    relative_width:     Width of peak.
    relative_max:       Y value corresponding to the peak width (float).
    dx:                 Pixel size for x dimension (float).
    units:              Units of the x dimension (string: 'cm', 'mm').
    """
    
    x = np.linspace(start=-(len(y)*dx)/2, stop=(len(y)*dx)/2, num=len(y))
    y = y - relative_max
    
    area = np.trapz(y, dx=dx)
    if units == 'cm':
        b = np.linspace(0,1,1000)
    elif units == 'mm':
        b = np.linspace(0,10,1000)
    a = relative_width/2*dx
    minimize = np.zeros(len(b))
    
    for i, R in enumerate(b):
        check_area = (1/2)*np.pi*a*R
        minimize[i] = abs(area - check_area)
        
    y = y + relative_max
        
    fitted_radius = b[np.argmin(minimize)]
    data_graph = {"x": x, "y": y}
    fitted_graph = {"center": (0, relative_max), "a": a, "b": fitted_radius}
    
    return fitted_radius, fitted_graph, data_graph

def plot_ellipse(data_graph, fitted_graph, save_path=None):
    t = np.linspace(0, np.pi)
    a = fitted_graph["a"]
    b = fitted_graph["b"]
    xc = fitted_graph["center"][0]
    yc = fitted_graph["center"][1]
    
    plt.figure()
    plt.plot(data_graph["x"], data_graph["y"], label="Data w/ Full Width = " + str(round(a*2,2)) + " cm")
    plt.plot(xc+a*np.cos(t), yc+b*np.sin(t), label="Fitted Ellipse w/ Diameter = " + str(round(b,2)) + " cm")
    plt.legend()
    plt.title('Ellipse Fitting to EPL Scan')
    plt.xlabel('Horizontal Location [cm]')
    plt.ylabel('EPL [cm]')
    if save_path is not None:
        plt.savefig(save_path)